# M320 - Data Modeling
Learn everything you need to know about data modeling for MongoDB.

## Introduction to Data Modeling
### The document model in MongoDB
- MongoDB stores data as Documents. [Document structure][documentStructure]
- Document fields can be values, embedded documents, or arrays of values and documents.
- MongoDB is a flexive Schema database.
- MongoDB documents are stored as BSON documents.
- [Supported datatypes][supportDatatypes]

Example:

```json
{
    "firstName": "John",
    "lastName": "Doe",
    "age": 25,
    "address": {
        "city": "Capitol",
        "state": "Moosylvania",
        "street": "One"
    },
    "phones": [
        "987654123", "389748323"
    ]
}
```


### Constraints in data modeling

- Keep the frequently used Documents in RAM
- Keep the Indexes in RAM
- Prefer SSD to HDD
- Infrequently data can use HDD
- The nature of your dataset and hardware define the need to model your data
  - It is important to identify those exact constraints and their impact to create a better model
  - As your software and the technological landscape change, your model should be re-evaluated and updated accordingly.
- Avoid [Transactions][transactions]
  - [Transactions videos][transactionVideos]


### Data modeling methodology diagram
- Workload
  - Data size, important reads and writes
- Relationships
  - Identify them, link or embed the related entities
- Patterns
  - Apply the ones for needed optimizations

![Data modeling methodology diagram](/images/m320-methodology-diagram.png ':size=300xHEIGHT')


### Model for simplicity or Performance
**Modeling for Simplicity Diagram**

![Modeling for Simplicity Diagram](/images/m320-modeling-simplicity-diagram.png ':size=300xHEIGHT')

**Modeling for Performance Diagram**

![Modeling for Simplicity Diagram](/images/m320-modeling-performance-diagram.png ':size=300xHEIGHT')

**Modeling for a Mix of Simplicity and Performance Diagram**

![Modeling for Simplicity Diagram](/images/m320-modeling-mix-diagram.png ':size=300xHEIGHT')

**Summary of Modeling Approaches**

![Modeling for Simplicity Diagram](/images/m320-modeling-summary.png ':size=300xHEIGHT')


### Identifying the workload
- Quantify and qualify the queries as much as you can.
- Few CRUD operations will drive the design.

Examples of data with their desired durability

| Type of data                      | Durability      | MongoDB notation |
| --------------------------------- | --------------- | ---------------- |
| Money                             | majority        | w=majority       |
| Account information               | majority        | w=majority       |
| ...anything that you can't lose   | majority        | w=majority       |
| Log data                          | one node        | w=1              |
| Sensor data                       | one node        | w=1              |
| Stock quotes, few per second data | fire and forget | w=0              |



## Relationships
### Types and Cardinality
- Common Relationships
  - one to one (1-1)
  - one to many (1-N)
  - many to many (N-N)
  - one to zillions (1-[minimum, likely, maximum]) Used in Big data.

### One to Many
- Embed
  - in the "one" side
    - The documents from the "many" side are embedded
    - Most common representation for: simple applications or few documents to embed
    - Need to process main object and the N related documents together
    - Indexing is done on the array
  - in the "many" side
    - Less often used
    - Useful if "many" side is queried more often than the "one" side
    - Embedded object is duplicated, duplication may be preferable for dynamic objects
  - Usually, embedding in the entity the most queried
- Reference
  - in the "one" side
    - Array of references
    - Allows for large documents and a high count of these
    - List of references available when retrieving the main object
    - Cascade deletes are not supported by MongoDB and must be managed by the application
  - in the "many" side
    - Preferred representation using references
    - Allows for large documents and a high count of these
    - No need to manage the references on the "one" side.
  - Usually, referencing in the "many" side

### Many to Many
- Embed
  - Array of subdocuments in the "many" side
    - The documents from the less queried side are embedded
    - Results in duplication
    - Keep "source" for the embedded documents in another collection
    - Indexing is done on the array
  - Array of subdocuments in the other "many" side
  - Usually, only the most queried side is considered
  - Prefer embedding on the most queried side
  - Prefer embedding for information that is primarily static over time and may profit from duplication
- Reference
  - Array of references in one "many" side
    - Array of references to the documents of the other collection
    - References readily available upon first query on the "main" collection
  - Array of references in the other "many" side
    - Array of references to the documents of the other collection
    - Need a second query to get more information
  - Prefer referencing over embedding to avoid managing duplication

### One to One
- Prefer embedding over referencing for simplicity
- Embed
  - Fields at same level
  - Grouping in sub-documents
- Reference
  - Same identifier in both documents
  - In the main "one" side
  - In the secondary "one" side
  - Add complexity
  - Possible performance improvements with:
    - smaller disk access
    - smaller amount of RAM needed

### One to Zillions
- Reference
  - in the "many/zillions" side


## Patterns

[documentStructure]: https://docs.mongodb.com/manual/core/data-modeling-introduction/#document-structure
[supportDatatypes]: https://docs.mongodb.com/master/reference/bson-types/
[transactions]: https://docs.mongodb.com/manual/core/transactions/
[transactionVideos]: https://www.mongodb.com/transactions
