# M201: MongoDB Performance

---

## Hardware considerations & configurations

Server can be represented by the Von Neumann architecture:
- **CPU** for processing and calculations.
- **Memory** for execution.
- **Disk and IO** for persistency and communications between servers, or even within our host processes.

In MongoDB, as in many other modern databases, memory is a quintessential resource. A significant number of operations rely heavily in RAM:
- The aggregation pipeline operations.
- The index traversing.
- Writes are first performed in RAM allocated pages.
- The query engine requires RAM to retrieve the quarter results.
- Connections are handling memory. Roughly, one megabyte per established connection.

CPU is used by all applications for computational processing, but the utilization of this resource is generally more attached with two main factors:
- Storage engines that we are using.
- The concurrency level that your MongoDB instance will be subjected to.

By default, MongoDB will try to use all available CPU cores to respond to incoming requests.
Our non-locking concurrency control mechanism, using wired tag or storage engine, rely heavily in the CPU to process these requests.

This means that if we have non-blocking operations, like writing different documents concurrently or responding to an incoming query requests like Reads, MongoDB will perform better the more CPU resources we have available.

Also, **there are certain operations, like page compression, data calculation operations, aggregation framework operations, and map reduce, amongst others that will require the availability of CPU cycles**.

But **do not forget that not all writes and read operations are non-locking operations**.

Writing constantly to the same document, for example, and in similar place updates will require each write to block all other writes on that same document to comply.

In situations such as this, multiple CPU's do not help performance. Because the threads can not do their work in parallel. Since always the same document will be affected by the same write.

**For persisting data, MongoDB will use disks**. And the faster your persistency layer will respond to database and application requests. The types of disks will greatly affect the overall performance of your MongoDB deployment.

If we compare the different types of disks: HDDs, SSDs, EBS, volumes, in terms of random access latency and IOPS, we can immediately tell that there is going to be a big difference between what one can expect, in terms of performance, given the different types of disks that we might be using.

This can be used in different architectures.

More specifically, we can use RAID architectures in our servers for redundancy of read and write operations. `The recommended RAID architecture for MongoDB deployments is RAID 10, or RAID 1-0.` This architecture is the one that offers more redundancy and safeguards guarantees with a good performance combination.

Also, the types of network switches, load balancers, firewalls, and how far apart the cluster nodes are-- either by being distributed across different data centers or regions.

The type of connections between data centers, especially latency-- we haven't cracked going faster than the speed of light yet-- will play a great deal in the performance experienced by your application.

This aligned with the write concern, read concern, and read preference that your application can set while emitting commands or doing requests to the server, needs to be taken into consideration when analyzing the performance of your application.


## How data is stored on disk
[More info][mongodbStorageData]


## Indexes
[More info][mongodbIndexes]

### Single field
[More info][singleIndex]

- Simplest indexes in MongoDB
- `db.<collection>.createIndex({ "<field>": "<direction>" })`
- Key features:
    - Keys from only one field.
    - Can find a single value for the indexed field.
    - Can find a range of values.
    - Can use dot notation to index fields in subdocument.
    - Can be used to find several distinct values in a single query.

Examples
```js
// execute the following query and collect execution statistics
db.people.find({ "ssn" : "720-38-5636" }).explain("executionStats")

// create an ascending index on ssn
db.people.createIndex( { ssn : 1 } )

// create an explainable object for the people collection
exp = db.people.explain("executionStats")
```



[mongodbIndexes]: https://docs.mongodb.com/manual/indexes
[mongodbStorageData]: https://docs.mongodb.com/manual/faq/storage
[singleIndex]: https://docs.mongodb.com/manual/core/index-single