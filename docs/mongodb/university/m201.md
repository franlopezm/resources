# M201: MongoDB Performance

---

## Hardware considerations & configurations

Server can be represented by the Von Neumann architecture:
- **CPU** for processing and calculations.
- **Memory** for execution.
- **Disk and IO** for persistency and communications between servers, or even within our host processes.

In MongoDB, as in many other modern databases, memory is a quintessential resource. A significant number of operations rely heavily in RAM:
- The aggregation pipeline operations.
- The index traversing.
- Writes are first performed in RAM allocated pages.
- The query engine requires RAM to retrieve the quarter results.
- Connections are handling memory. Roughly, one megabyte per established connection.

CPU is used by all applications for computational processing, but the utilization of this resource is generally more attached with two main factors:
- Storage engines that we are using.
- The concurrency level that your MongoDB instance will be subjected to.

By default, MongoDB will try to use all available CPU cores to respond to incoming requests.
Our non-locking concurrency control mechanism, using wired tag or storage engine, rely heavily in the CPU to process these requests.

This means that if we have non-blocking operations, like writing different documents concurrently or responding to an incoming query requests like Reads, MongoDB will perform better the more CPU resources we have available.

Also, **there are certain operations, like page compression, data calculation operations, aggregation framework operations, and map reduce, amongst others that will require the availability of CPU cycles**.

But **do not forget that not all writes and read operations are non-locking operations**.

Writing constantly to the same document, for example, and in similar place updates will require each write to block all other writes on that same document to comply.

In situations such as this, multiple CPU's do not help performance. Because the threads can not do their work in parallel. Since always the same document will be affected by the same write.

**For persisting data, MongoDB will use disks**. And the faster your persistency layer will respond to database and application requests. The types of disks will greatly affect the overall performance of your MongoDB deployment.

If we compare the different types of disks: HDDs, SSDs, EBS, volumes, in terms of random access latency and IOPS, we can immediately tell that there is going to be a big difference between what one can expect, in terms of performance, given the different types of disks that we might be using.

This can be used in different architectures.

More specifically, we can use RAID architectures in our servers for redundancy of read and write operations. `The recommended RAID architecture for MongoDB deployments is RAID 10, or RAID 1-0.` This architecture is the one that offers more redundancy and safeguards guarantees with a good performance combination.

Also, the types of network switches, load balancers, firewalls, and how far apart the cluster nodes are-- either by being distributed across different data centers or regions.

The type of connections between data centers, especially latency-- we haven't cracked going faster than the speed of light yet-- will play a great deal in the performance experienced by your application.

This aligned with the write concern, read concern, and read preference that your application can set while emitting commands or doing requests to the server, needs to be taken into consideration when analyzing the performance of your application.


## How data is stored on disk
[More info][mongodbStorageData]


## Indexes
[More info][mongodbIndexes]

### Single field
[More info][singleIndex]

- Simplest indexes in MongoDB
- `db.<collection>.createIndex({ "<field>": "<direction>" })`
- Key features:
    - Keys from only one field.
    - Can find a single value for the indexed field.
    - Can find a range of values.
    - Can use dot notation to index fields in subdocument.
    - Can be used to find several distinct values in a single query.

Examples
```js
// execute the following query and collect execution statistics
db.people.find({ "ssn" : "720-38-5636" }).explain("executionStats")

// create an ascending index on ssn
db.people.createIndex( { ssn : 1 } )

// create an explainable object for the people collection
exp = db.people.explain("executionStats")
```

### Understand explain()
[More Info][explainMethod]

Use **explain method** on a query is the best way to analyze what happens when the query is executed.
- Execution time.
    - Is our index providing us a sort?
    - what's the most expensive stage in our query plan?
- Plans (Indexes) selected and rejected.
    - It can tell us, is our query using the index that we expected?
    - Can our index provide a projection?
- Number of keys read, documents read and documents returned.
    - How selective is our index?

Appending the explain method to the end of our query, examples:
```js
// create an explainable object with no parameters
exp = db.people.explain()

// create an explainable object with the 'executionStats' parameter
expRun = db.people.explain("executionStats")

// and one final explainable object with the 'allPlansExecution' parameter
expRunVerbose = db.people.explain("allPlansExecution")

// execute and explain the query, collecting execution statistics
expRun.find({"last_name":"Johnson", "address.state":"New York"})
```

### Sorting with indexes
[More info][sortIndexes]

Methods for sorting:
- In memory
    - 32 megabytes limit
- Using an index
    - That can be used for a combination of ascending and descending sorting orders.
    - Use indexes to both match and sort on a single query.

### Querying on Compound Indexes
[More info][compoundIndex]

A compound index is an index on two or more fields, and it can support queries based on those fields.

```
db.collection.createIndex( { "<field1>": "<type>", "<field2>": "<type2>", ... } )
```

- [Create indexes to support queries][indexSupportQueries]
- [Use indexes to sort query results][indexSortResults]
- We can sort our queries by using index prefixes in our sort predicates.
- We can filter and sort our queries by splitting up our index prefix between our query and sort predicates. Important to remember that our query part has to precede the sort part and that these have to be equality matches.
- We can sort our documents with an index if our sort predicate inverts our index keys or their prefixes.


### Multikey indexes
[More info][multikeyIndexes]

To index a field that holds an array value, MongoDB creates an index key for each element in the array. These multikey indexes support efficient queries against array fields. Multikey indexes can be constructed over arrays that hold both scalar values (e.g. strings, numbers) and nested documents.

Limitations:
- You cannot create a compound multikey index if more than one to-be-indexed field of a document is an array. For example, consider a collection that contains the following document:

    ```json
        { _id: 1, a: [ 1, 2 ], b: [ 1, 2 ], category: "AB - both arrays" }
    ```
   You cannot create a compound multikey index { a: 1, b: 1 } on the collection since both the a and b fields are arrays.

- Or, if a compound multikey index already exists, you cannot insert a document that would violate this restriction. Consider a collection that contains the following documents:
    ```json
        { _id: 1, a: [1, 2], b: 1, category: "A array" }
        { _id: 2, a: 1, b: [1, 2], category: "B array" }
    ```
    A compound multikey index { a: 1, b: 1 } is permissible since for each document, only one field indexed by the compound multikey index is an array; i.e. no document contains array values for both a and b fields.

    However, after creating the compound multikey index, if you attempt to insert a document where both a and b fields are arrays, MongoDB will fail the insert.


### Partial indexes
[More info][partialIndex]

Only index the documents in a collection that meet a specified filter expression. By indexing a subset of the documents in a collection, partial indexes have lower storage requirements and reduced performance costs for index creation and maintenance.

```js
db.restaurants.createIndex(
   { cuisine: 1, name: 1 },
   { partialFilterExpression: { rating: { $gt: 5 } } }
)
```

Limitations:
- You cannot specify both the partialFilterExpression option and the sparse option.
- _id indexes cannot be partial indexes.
- Shard key indexes cannot be partial indexes.


### Text indexes
[More info][textIndex]

MongoDB provides text indexes to support text search queries on string content. text indexes can include any field whose value is a string or an array of string elements.

```js
db.reviews.createIndex(
    { "<field>": "text" },
    { default_language: "spanish" }
)
```


### Collations
[More info][collations]

Collation allows users to specify language rules for string comparison, such as rules for lettercase and accent marks.

You can specify collation for a collection or a view, an index, or specific operations that support collation.

Collation document:
```json
{
   locale: "<string>",
   caseLevel: "<boolean>",
   caseFirst: "<string>",
   strength: "<int>",
   numericOrdering: "<boolean>",
   alternate: "<string>",
   maxVariable: "<string>",
   backwards: "<boolean>"
}
```

[mongodbIndexes]: https://docs.mongodb.com/manual/indexes
[mongodbStorageData]: https://docs.mongodb.com/manual/faq/storage
[singleIndex]: https://docs.mongodb.com/manual/core/index-single
[compoundIndex]: https://docs.mongodb.com/manual/core/index-compound
[indexSupportQueries]: https://docs.mongodb.com/manual/tutorial/create-indexes-to-support-queries
[indexSortResults]: https://docs.mongodb.com/manual/tutorial/sort-results-with-indexes
[multikeyIndexes]: https://docs.mongodb.com/manual/core/index-multikey
[partialIndex]: https://docs.mongodb.com/manual/core/index-partial
[textIndex]: https://docs.mongodb.com/manual/core/index-text
[collations]: https://docs.mongodb.com/manual/reference/collation
[explainMethod]: https://docs.mongodb.com/manual/reference/method/cursor.explain
[sortIndexes]: https://docs.mongodb.com/manual/tutorial/sort-results-with-indexes