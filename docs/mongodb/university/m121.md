# M121 - The MongoDB Aggregation Framework

## Aggregations syntax {docsify-ignore}
[Quick reference][quickReference]
[Variables][variables]

```js
db.collection.aggregate([{ Stage1 }, { Stage2 }, { Stage3 }, ...], { Options })
```


## Basic Aggregation

### $match
- A $match stage may contain a $text query operator, but it must be the first stage in a pipeline
- $match should come early in an aggregation pipeline
- You cannot use $where with $match
- $match uses the same query syntax as find

### $project
- Once we specify one field to retain, we must specify all fields we want to retain. The _id field is the only exception to this
- Beyond simply removing and retaining fields, $project lets us add new fields
- $project can be used as many times as required within an Aggregation pipeline
- $project can be used to reassign values to existing field names and to derive entirely new fields

Example
```js
// If we'd like to analyze our collection to find movie titles that are composed of only one word
db.movies.aggregate([
    {
        $project: {
           count: {$size: { $split: ["$title", ' '] }},
           _id: 0
        }
    }, {
        $match: {
            count: {$lte: 1}
        }
    }
]).itcount()
```

### $geoNear
[More info here][geoNear]

- $geoNear must be the first stage in an aggregation pipeline
- The collection can have one and only one 2dsphere index
- If using 2dsphere, the distance is returned in meters. If using legacy coordinates, the distance is returned in radians

### $sort
- $sort can take advantage of indexes if used early within a pipeline
- By default, $sort will only use up to 100 megabytes of RAM. Setting `{ allowDiskUse: true }` will allow for larger sorts

Example
```js
/**
Calculate an average rating for each movie in our collection where English is an available language, the minimum imdb.rating is at least 1, the minimum imdb.votes is at least 1, and it was released in 1990 or after. You'll be required to rescale (or normalize) imdb.votes. The formula to rescale imdb.votes and calculate normalized_rating is included as a handout.
*/
db.movies.aggregate([
  {
    $match: {
      year: { $gte: 1990 },
      languages: { $in: ["English"] },
      "imdb.votes": { $gte: 1 },
      "imdb.rating": { $gte: 1 }
    }
  },
  {
    $project: {
      _id: 0,
      title: 1,
      "imdb.rating": 1,
      "imdb.votes": 1,
      normalized_rating: {
        $avg: [
          "$imdb.rating",
          {
            $add: [
              1,
              {
                $multiply: [
                  9,
                  {
                    $divide: [
                      { $subtract: ["$imdb.votes", 5] },
                      { $subtract: [1521105, 5] }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  { $sort: { normalized_rating: 1 } },
  { $limit: 1 }
])
```


## Core Aggregation

### $group
[More info here][group]

- _id is where to specify what incoming documents should be grouped on
- Can use all accumulator expressions within $group
- $group can be used multiple times within a pipeline
- It may be necessary to sanitize incoming data

### $unwind
[More info here][unwind]

- $unwind only works on array values
- Using unwind on large collections with big documents may lead to performance issues. Setting `{ allowDiskUse: true }`

### $lookup
[More info here][lookup]

Syntax:
```js
{
   $lookup:
     {
       from: "<collection to join>",
       localField: "<field from the input documents>",
       foreignField: "<field from the documents of the 'from' collection>",
       as: "<output array field>"
     }
}
```

- The **from** collection cannot be sharded, and must be in the same database
- The values in **localField** and **foreignField** are matched on equality
- **as** can be any name, but if it exists in the working document that field will be overwritten

Example
```js
// Which alliance from air_alliances flies the most routes with either a Boeing 747 or an Airbus A380 (abbreviated 747 and 380 in air_routes)?
db.air_routes.aggregate([{
    $match: {
        airplane: {$in: ["747", "380"]}
    }
}, {
    $lookup: {
        from: "air_alliances",
        localField: "airline.name",
        foreignField: "airlines",
        as: "routes"
    }
}, {
    $unwind: "$routes"
},
{
    $group: {
        _id: "$routes.name",
        count: {$sum: 1}
    }
}])
```

### $graphLookup
[More info here][graphLookup]

Syntax:
```js
{
   $graphLookup: {
      from: "<collection>",
      startWith: "<expression>",
      connectFromField: "<string>",
      connectToField: "<string>",
      as: "<string>",
      maxDepth: "<number>",
      depthField: "<string>",
      restrictSearchWithMatch: "<document>"
   }
}
```

- The $graphLookup stage must stay within the 100 MiB memory limit. If `{ allowDiskUse: true }` is specified for the aggregate() operation, the $graphLookup stage ignores the option
- Not allow in sharding collections

[quickReference]: https://docs.mongodb.com/manual/meta/aggregation-quick-reference/
[variables]: https://docs.mongodb.com/manual/reference/aggregation-variables/
[geoNear]: https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/
[group]: https://docs.mongodb.com/manual/reference/operator/aggregation/group
[unwind]: https://docs.mongodb.com/manual/reference/operator/aggregation/unwind/
[lookup]: https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/
[graphLookup]: https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/
