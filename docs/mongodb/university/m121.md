# M121 - The MongoDB Aggregation Framework

## Aggregations syntax {docsify-ignore}
[Quick reference][quickReference]
[Variables][variables]

```js
db.collection.aggregate([{ Stage1 }, { Stage2 }, { Stage3 }, ...], { Options })
```


## Basic Aggregation

### $match
- A $match stage may contain a $text query operator, but it must be the first stage in a pipeline
- $match should come early in an aggregation pipeline
- You cannot use $where with $match
- $match uses the same query syntax as find

### $project
- Once we specify one field to retain, we must specify all fields we want to retain. The _id field is the only exception to this
- Beyond simply removing and retaining fields, $project lets us add new fields
- $project can be used as many times as required within an Aggregation pipeline
- $project can be used to reassign values to existing field names and to derive entirely new fields

Example
```js
// If we'd like to analyze our collection to find movie titles that are composed of only one word
db.movies.aggregate([
    {
        $project: {
           count: {$size: { $split: ["$title", ' '] }},
           _id: 0
        }
    }, {
        $match: {
            count: {$lte: 1}
        }
    }
]).itcount()
```

### $geoNear
[More info here][geoNear]

- $geoNear must be the first stage in an aggregation pipeline
- The collection can have one and only one 2dsphere index
- If using 2dsphere, the distance is returned in meters. If using legacy coordinates, the distance is returned in radians

### $sort
- $sort can take advantage of indexes if used early within a pipeline
- By default, $sort will only use up to 100 megabytes of RAM. Setting `{ allowDiskUse: true }` will aloow for larger sorts

Example
```js
/**
Calculate an average rating for each movie in our collection where English is an available language, the minimum imdb.rating is at least 1, the minimum imdb.votes is at least 1, and it was released in 1990 or after. You'll be required to rescale (or normalize) imdb.votes. The formula to rescale imdb.votes and calculate normalized_rating is included as a handout.
*/
db.movies.aggregate([
  {
    $match: {
      year: { $gte: 1990 },
      languages: { $in: ["English"] },
      "imdb.votes": { $gte: 1 },
      "imdb.rating": { $gte: 1 }
    }
  },
  {
    $project: {
      _id: 0,
      title: 1,
      "imdb.rating": 1,
      "imdb.votes": 1,
      normalized_rating: {
        $avg: [
          "$imdb.rating",
          {
            $add: [
              1,
              {
                $multiply: [
                  9,
                  {
                    $divide: [
                      { $subtract: ["$imdb.votes", 5] },
                      { $subtract: [1521105, 5] }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    }
  },
  { $sort: { normalized_rating: 1 } },
  { $limit: 1 }
])
```


## Core Aggregation


[quickReference]: https://docs.mongodb.com/manual/meta/aggregation-quick-reference/
[variables]: https://docs.mongodb.com/manual/reference/aggregation-variables/
[geoNear]: https://docs.mongodb.com/manual/reference/operator/aggregation/geoNear/
